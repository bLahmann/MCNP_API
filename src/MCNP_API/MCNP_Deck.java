package MCNP_API;

import java.util.*;

/**
 * Created by lahmann on 06/04/2015.
 */
public class MCNP_Deck extends MCNP_Object {

    private String name;

    private ArrayList<MCNP_Surface> surfaces = new ArrayList<>();
    private ArrayList<MCNP_Cell> cells = new ArrayList<>();
    private ArrayList<MCNP_Tally> tallies = new ArrayList<>();
    private ArrayList<MCNP_MeshTally> meshTallies = new ArrayList<>();
    private ArrayList<MCNP_Particle> particlesToSimulate = new ArrayList<>();
    private ArrayList<Parameter> parameters = new ArrayList<>();
    private Integer numberOfParticles = 0;
    private MCNP_Source source;

    public MCNP_Deck(String name){
        /**
         * TODO: This is a horrible way to handle this problem, decks should have their own private counters that they use when writing the strings.
         * TODO: The uuid should not be a component of the MCNP_Objects because it is not fundamentally a component of the object since it's only relevant to the deck
         */
        MCNP_Material.totalMaterials = 0;
        MCNP_Distribution.totalDistributions = 0;
        MCNP_Surface.totalSurfaces = 0;
        MCNP_Tally.totalTallies = 0;
        MCNP_Cell.totalCells = 0;

        this.name = name;
    }

    public void addCell(MCNP_Cell cell){
        cells.add(cell);
    }

    public void addTally(MCNP_Tally tally){
        tallies.add(tally);
    }

    public void addMeshTally(MCNP_MeshTally meshTally){
        meshTallies.add(meshTally);
    }

    public void addSurface(MCNP_Surface surface){
        surfaces.add(surface);
    }

    public void addParticleToSimulate(MCNP_Particle particleToSimulate){
        particlesToSimulate.add(particleToSimulate);
    }

    public void addParameter(String name, Object parameter){
        if(parameters.isEmpty()){
            parameters.add(new Parameter("Parameter", "Value"));
        }

        if (parameter == null){
            parameters.add(new Parameter(name, "null"));
        }
        else if (parameter.getClass() == MCNP_Material.class){          // TODO: generalize this to MCNP Objects
            MCNP_Material material = (MCNP_Material) parameter;
            parameters.add(new Parameter(name, material.getName()));
        }
        else {
            parameters.add(new Parameter(name, parameter.toString()));
        }
    }

    public void setSource(MCNP_Source source, Integer numberOfParticles){
        this.source = source;
        this.numberOfParticles = numberOfParticles;
    }

    public void toConsole(){
        System.out.println(this);
    }

    public String toString(){
        Vector<MCNP_Material> uniqueMaterials = new Vector<MCNP_Material>();
        Vector<String> lines = new Vector<String>();

        // Write title information
        lines.add(MCNP_API_Utilities.centerString(this.name, 80));
        lines.add(MCNP_API_Utilities.commentLine);
        lines.add("C " + MCNP_API_Utilities.centerString("Deck generated by MCNP API", 76));
        lines.add("C " + MCNP_API_Utilities.centerString("Author: " + System.getProperty("user.name"), 76));
        lines.add("C ");

        for(Parameter parameter : parameters){
            lines.add(parameter.toString());
        }
        lines.add("C ");

        // Write cell cards
        lines.add(MCNP_API_Utilities.commentLine);
        lines.add("C *" + MCNP_API_Utilities.centerString("CELL CARDS", 74) + "  *");
        lines.add(MCNP_API_Utilities.commentLine);
        lines.add("C ");

        // TODO: Temp line
        ArrayList<String> voidCellLines = new ArrayList<>();
        String voidLine = "999 0";

        for(MCNP_Cell cell : cells){
            lines.add(cell.toString());


            if(voidLine.length() + String.format(" #%d", cell.getID()).length() > 78) {
                voidCellLines.add(voidLine);
                voidLine = "        ";
            }
            voidLine += String.format(" #%d", cell.getID());


            for(MCNP_Surface surface : cell.getSurfaces()){
                if(!surfaces.contains(surface)){
                    surfaces.add(surface);
                }
            }

            if(cell.getMaterial() != null && !uniqueMaterials.contains(cell.getMaterial())){
                uniqueMaterials.add(cell.getMaterial());
            }
        }


        voidCellLines.add(voidLine);
        for (String card : voidCellLines) {
            lines.add(card);
        }

        lines.add("");

        // Write surface cards
        lines.add(MCNP_API_Utilities.commentLine);
        lines.add("C *" + MCNP_API_Utilities.centerString("SURFACE CARDS", 74) + "  *");
        lines.add(MCNP_API_Utilities.commentLine);
        lines.add("C ");

        surfaces.sort(Comparator.comparingInt(MCNP_Surface::getID));
        for(MCNP_Surface surface : surfaces){
            lines.add(surface.toString());
        }
        lines.add("");

        // Write data cards
        lines.add(MCNP_API_Utilities.commentLine);
        lines.add("C *" + MCNP_API_Utilities.centerString("DATA CARDS", 74) + "  *");
        lines.add(MCNP_API_Utilities.commentLine);
        lines.add("C ");

        String modeCard = new String("MODE ");
        for(MCNP_Particle particle : particlesToSimulate){
            modeCard += particle.getId() + " ";
        }
        lines.add(modeCard);
        lines.add("NPS  " + String.format("%.4e", 1.0*numberOfParticles));

        lines.add("PRDMP " + String.format("%.4e", 1.0*numberOfParticles) + " " +       // ndp (# of histories till we write to output)
                String.format("%.4e", 0.2*numberOfParticles) + " " +                    // ndm (# of histories till we write to runtpe)
                String.format("%.4e", 0.0) + " " +                                      // mct TODO: turn mctal on if mesh tally
                String.format("%.4e", 5.0) + " " +                                      // ndmp (Max cycles to store on the runtpe)
                String.format("%.4e", 1.0*numberOfParticles));                          // dmmp (How often TFC occur / I never use these)

        for(MCNP_Particle particle : particlesToSimulate){
            lines.add(particle.getPhysicsCard());
            lines.add(particle.getCutoffCard());

            ArrayList<String> importanceCards = new ArrayList<String>();
            ArrayList<String> forcedCollisionCards = new ArrayList<String>();
            String importanceCard = "imp:" + particle.getId() + " ";
            String forcedCollisionsCard = "fcl:" + particle.getId() + " ";

            for(MCNP_Cell cell : cells){
                String importance = cell.getImportance().toString() + " ";
                String forcedCollisions = cell.getForcedCollisions().toString() + " ";

                if(importanceCard.length() + importance.length() > 77) {
                    importanceCards.add(importanceCard);
                    importanceCard = "        ";
                }
                if(forcedCollisionsCard.length() + forcedCollisions.length() > 77) {
                    forcedCollisionCards.add(forcedCollisionsCard);
                    forcedCollisionsCard = "        ";
                }

                importanceCard += importance;
                forcedCollisionsCard += forcedCollisions;
            }

            // This extra addition is related to the hard coded "void card"
            importanceCard += "1";
            importanceCards.add(importanceCard);
            for (String card : importanceCards) {
                lines.add(card);
            }

            forcedCollisionsCard += "0.0";
            forcedCollisionCards.add(forcedCollisionsCard);
            for (String card : forcedCollisionCards) {
                if (particle.getId().equals("n"))
                lines.add(card);
            }

        }

        for(MCNP_Material material : uniqueMaterials){
            lines.add(material.toString());
        }

        lines.add(source.toString());

        for(MCNP_Tally tally : tallies){
            lines.add(tally.toString());
        }

        for (MCNP_MeshTally meshTally : meshTallies){
            lines.add(meshTally.toString());
        }


        String finalString = new String();
        Iterator<String> iterator = lines.iterator();
        while(iterator.hasNext()){
            finalString += iterator.next();
            if(iterator.hasNext())
                finalString += "\n";
        }

        return finalString;
    }

    public class Parameter{
        private String name;
        private String value;

        public Parameter(String name, String value) {
            this.name = name;
            this.value = value;
        }

        public String toString(){
            String s = "C ";
            for(int i = 0; i < 38 - name.length(); i++){
                s += " ";
            }
            s += name + " : " + value;

            return s;
        }
    }





}
